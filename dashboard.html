<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mestinon Einnahme Protokoll Dashboard</title>
    <!-- Add D3.js library -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        header {
            margin-bottom: 20px;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .patient-info {
            background-color: #fff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .visualization-container {
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow-x: auto;
            margin-bottom: 20px;
        }
        
        #visualization {
            min-height: 500px;
            width: 100%;
        }
        
        .controls {
            background-color: #fff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .filter-item {
            background-color: #eee;
            border-radius: 15px;
            padding: 5px 10px;
            cursor: pointer;
            user-select: none;
        }
        
        .filter-item.active {
            background-color: #2c3e50;
            color: white;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
        
        .tooltip {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 300px;
            z-index: 100;
        }
        
        .tooltip h3 {
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .tooltip p {
            margin: 5px 0;
            font-size: 12px;
        }
        
        .axis-label {
            font-size: 12px;
            fill: #555;
        }
        
        /* Zoom controls styling */
        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            background: white;
            padding: 5px;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            z-index: 100;
        }
        
        .zoom-controls button {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 14px;
            padding: 5px 10px;
            cursor: pointer;
            margin: 0 3px;
            transition: background 0.2s;
        }
        
        .zoom-controls button:hover {
            background: #e9ecef;
        }
        
        .zoom-controls button:active {
            background: #dee2e6;
        }
        
        .zoom-controls .zoom-level {
            margin: 0 8px;
            font-size: 12px;
            color: #666;
        }
        
        .zoom-tooltip {
            position: absolute;
            top: 45px;
            right: 10px;
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 3px;
            padding: 8px;
            font-size: 12px;
            max-width: 220px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }
        
        .zoom-controls:hover + .zoom-tooltip {
            opacity: 1;
        }
        
        .analysis-section {
            background-color: #fff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .half-life-estimation {
            background-color: #f0f8ff;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .visualization-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1 id="title">Mestinon Einnahme Protokoll</h1>
        <p id="description">Erfahrungen mit Mestinon</p>
    </header>
    
    <div class="patient-info">
        <h2>Patient Information</h2>
        <div id="patient-details"></div>
    </div>
    
    <div class="controls">
        <h2>Filter</h2>
        <div class="filters" id="event-filters">
            <!-- Filter items will be generated here -->
        </div>
    </div>
    
    <div class="visualization-container">
        <div id="visualization">
            <!-- SVG will be inserted here -->
        </div>
        <div class="legend" id="event-legend">
            <!-- Legend items will be generated here -->
        </div>
    </div>

    <div class="analysis-section">
        <h2>Analyse</h2>
        <div id="analysis-details">
            <!-- Analysis will be generated here -->
        </div>
        
        <div class="half-life-estimation">
            <h3>Schätzung der Eliminationshalbwertszeit</h3>
            <div id="half-life-estimation">
                <!-- Half-life estimation will be generated here -->
            </div>
        </div>
    </div>

    <div id="tooltip" class="tooltip"></div>
    
    <script>
        // Configuration
        const config = {
            margin: { top: 40, right: 40, bottom: 100, left: 100 },
            barHeight: 20,
            barPadding: 30,
            timeFormat: d3.timeFormat("%Y-%m-%d %H:%M"),
            timeFormatShort: d3.timeFormat("%H:%M"),
            dateParser: d3.timeParse("%Y-%m-%d %H:%M")
        };

        // Data state
        let originalData = null;
        let filteredData = null;
        let eventTypes = [];
        let activeFilters = [];
        let visibleEventTypes = []; // Array to track which event types are visible
        
        // Elements
        const visualizationEl = document.getElementById('visualization');
        const patientDetailsEl = document.getElementById('patient-details');
        const eventFiltersEl = document.getElementById('event-filters');
        const eventLegendEl = document.getElementById('event-legend');
        const tooltipEl = document.getElementById('tooltip');

        // Load the data
        async function loadData() {
            try {
                const response = await fetch('data/mestinon-intake-protocol.json');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error loading data:', error);
                visualizationEl.innerHTML = '<p>Error loading data. Please try again later.</p>';
                return null;
            }
        }

        // Process the data
        function processData(data) {
            // Update page title and description
            document.getElementById('title').textContent = data.meta.title || 'Mestinon Einnahme Protokoll';
            document.getElementById('description').textContent = data.meta.description || '';
            
            // Display patient information
            const patientInfo = [];
            if (data.meta.author) patientInfo.push(`<strong>Patient:</strong> ${data.meta.author}`);
            if (data.meta.weight) patientInfo.push(`<strong>Gewicht:</strong> ${data.meta.weight}`);
            if (data.meta.size) patientInfo.push(`<strong>Größe:</strong> ${data.meta.size}`);
            
            if (data.meta['medical-status'] && Array.isArray(data.meta['medical-status'])) {
                patientInfo.push(`<strong>Medizinischer Status:</strong> ${data.meta['medical-status'].join(', ')}`);
            }
            
            patientDetailsEl.innerHTML = patientInfo.join('<br>');
            
            // Process events
            const events = data.events.map(event => {
                return {
                    ...event,
                    date: config.dateParser(event.date)
                };
            }).filter(event => event.date !== null);
            
            // Sort events by date
            events.sort((a, b) => a.date - b.date);
            
            // Extract unique event types
            eventTypes = [...new Set(events.map(event => event.type))];
            
            return {
                meta: data.meta,
                events: events
            };
        }

        // Create filters
        function createFilters() {
            eventFiltersEl.innerHTML = '';
            
            // Add "All" filter
            const allFilter = document.createElement('div');
            allFilter.className = 'filter-item active';
            allFilter.textContent = 'Alle';
            allFilter.addEventListener('click', () => {
                document.querySelectorAll('.filter-item').forEach(item => {
                    item.classList.remove('active');
                });
                allFilter.classList.add('active');
                activeFilters = [];
                filterData();
                updateVisualization();
            });
            eventFiltersEl.appendChild(allFilter);
            
            // Add event type filters
            eventTypes.forEach(type => {
                const filterItem = document.createElement('div');
                filterItem.className = 'filter-item';
                filterItem.textContent = type;
                filterItem.addEventListener('click', () => {
                    if (filterItem.classList.contains('active')) {
                        filterItem.classList.remove('active');
                        activeFilters = activeFilters.filter(f => f !== type);
                    } else {
                        filterItem.classList.add('active');
                        activeFilters.push(type);
                    }
                    
                    // If no filters are active, activate "All"
                    if (activeFilters.length === 0) {
                        allFilter.classList.add('active');
                    } else {
                        allFilter.classList.remove('active');
                    }
                    
                    filterData();
                    updateVisualization();
                });
                eventFiltersEl.appendChild(filterItem);
            });
        }

        // Filter data based on active filters
        function filterData() {
            if (activeFilters.length === 0) {
                filteredData = originalData.events;
                visibleEventTypes = [...eventTypes]; // All event types are visible
            } else {
                filteredData = originalData.events.filter(event => 
                    activeFilters.includes(event.type)
                );
                // Update which event types are visible based on filtered data
                visibleEventTypes = [...new Set(filteredData.map(event => event.type))];
            }
        }

        // Create the legend
        function createLegend() {
            eventLegendEl.innerHTML = '';
            
            // Generate colors for each event type
            const colorScale = d3.scaleOrdinal(d3.schemeCategory10)
                .domain(eventTypes);
            
            // Create legend items
            eventTypes.forEach(type => {
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'legend-color';
                colorBox.style.backgroundColor = colorScale(type);
                
                const label = document.createElement('span');
                label.textContent = type;
                
                legendItem.appendChild(colorBox);
                legendItem.appendChild(label);
                eventLegendEl.appendChild(legendItem);
            });
        }

        // Create the visualization
        function createVisualization() {
            if (!originalData || !originalData.events || originalData.events.length === 0) {
                visualizationEl.innerHTML = '<p>Keine Daten verfügbar.</p>';
                return;
            }
            
            // Clear previous visualization
            visualizationEl.innerHTML = '';
            
            // Determine time range
            const timeExtent = d3.extent(originalData.events, d => d.date);
            timeExtent[0] = new Date(timeExtent[0].getTime() - 1000 * 60 * 60); // 1 hour before first event
            timeExtent[1] = new Date(timeExtent[1].getTime() + 1000 * 60 * 60); // 1 hour after last event
            
            // Determine visualization dimensions
            const width = visualizationEl.clientWidth - config.margin.left - config.margin.right;
            const height = (config.barHeight + config.barPadding) * visibleEventTypes.length + config.margin.top + config.margin.bottom;
            
            // Create the SVG element
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', height);
            svg.setAttribute('viewBox', `0 0 ${width + config.margin.left + config.margin.right} ${height}`);
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            visualizationEl.appendChild(svg);
            
            // Create the main group element
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `translate(${config.margin.left},${config.margin.top})`);
            svg.appendChild(g);
            
            // Create scales
            const xScale = d3.scaleTime()
                .domain(timeExtent)
                .range([0, width]);
            
            const yScale = d3.scaleBand()
                .domain(visibleEventTypes)
                .range([0, (config.barHeight + config.barPadding) * visibleEventTypes.length])
                .padding(0.1);
            
            const colorScale = d3.scaleOrdinal(d3.schemeCategory10)
                .domain(eventTypes);
                
            // Add zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.5, 5])  // Limit zoom level between 0.5x and 5x
                .on('zoom', zoomed);
                
            // Apply zoom behavior to SVG
            d3.select(svg).call(zoom);
            
            // Create a group for all elements that should be zoomed
            const zoomGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            zoomGroup.setAttribute('class', 'zoom-group');
            g.appendChild(zoomGroup);
            
            // Create a separate group for circles to maintain their aspect ratio
            const circlesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            circlesGroup.setAttribute('class', 'circles-group');
            zoomGroup.appendChild(circlesGroup);
            
            // Create a separate group for lines
            const linesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            linesGroup.setAttribute('class', 'lines-group');
            zoomGroup.appendChild(linesGroup);
            
            // Create a separate group for medication markers
            const markersGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            markersGroup.setAttribute('class', 'markers-group');
            zoomGroup.appendChild(markersGroup);
            
            // Track current zoom level
            let currentZoomLevel = 1;
            
            // Update zoom level display
            function updateZoomLevel(level) {
                currentZoomLevel = level;
                const zoomLevelEl = document.querySelector('.zoom-level');
                if (zoomLevelEl) {
                    zoomLevelEl.textContent = `Zoom: ${Math.round(level * 100)}%`;
                }
            }
            
            // Enhanced zoom function
            function zoomed(event) {
                const transform = event.transform;
                
                // Update zoom level indicator
                updateZoomLevel(transform.k);
                
                // Create the new x scale based on the zoom transform
                const newXScale = transform.rescaleX(xScale);
                
                // Update the x-axis
                d3.select(xAxisGroup).call(
                    d3.axisBottom(newXScale)
                        .ticks(d3.timeHour.every(4))
                        .tickFormat(d3.timeFormat("%d.%m %H:%M"))
                );
                
                // Update positions of all elements without distorting their shapes
                d3.selectAll('.circles-group circle').each(function() {
                    const circle = d3.select(this);
                    const cx = parseFloat(circle.attr('data-x'));
                    circle.attr('cx', newXScale(new Date(cx)));
                });
                
                d3.selectAll('.lines-group line').each(function() {
                    const line = d3.select(this);
                    const x1 = parseFloat(line.attr('data-x1'));
                    const x2 = parseFloat(line.attr('data-x2'));
                    line.attr('x1', newXScale(new Date(x1)));
                    line.attr('x2', newXScale(new Date(x2)));
                });
                
                d3.selectAll('.markers-group rect').each(function() {
                    const rect = d3.select(this);
                    const x = parseFloat(rect.attr('data-x'));
                    rect.attr('x', newXScale(new Date(x)) - 2);
                });
            }
            
            // Draw x-axis
            const xAxis = d3.axisBottom(xScale)
                .ticks(d3.timeHour.every(4))
                .tickFormat(d3.timeFormat("%d.%m %H:%M"));
            
            const xAxisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            xAxisGroup.setAttribute('transform', `translate(0,${(config.barHeight + config.barPadding) * visibleEventTypes.length})`);
            xAxisGroup.setAttribute('class', 'x-axis');
            g.appendChild(xAxisGroup);
            
            d3.select(xAxisGroup).call(xAxis)
                .selectAll("text")
                .attr("y", 10)
                .attr("x", -8)
                .attr("dy", ".35em")
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "end");
            
            // Draw y-axis
            const yAxis = d3.axisLeft(yScale);
            
            const yAxisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            yAxisGroup.setAttribute('class', 'y-axis');
            g.appendChild(yAxisGroup);
            
            d3.select(yAxisGroup).call(yAxis);
            
            // Add enhanced zoom controls
            const zoomControls = document.createElement('div');
            zoomControls.className = 'zoom-controls';
            zoomControls.innerHTML = `
                <button id="zoom-out" title="Zoom Out (Keyboard: -)">−</button>
                <div class="zoom-level">Zoom: 100%</div>
                <button id="zoom-in" title="Zoom In (Keyboard: +)">+</button>
                <button id="zoom-reset" title="Reset Zoom (Keyboard: 0)">Reset</button>
            `;
            visualizationEl.appendChild(zoomControls);
            
            // Add zoom tooltip with instructions
            const zoomTooltip = document.createElement('div');
            zoomTooltip.className = 'zoom-tooltip';
            zoomTooltip.innerHTML = `
                <strong>Zoom Controls:</strong><br>
                • Mouse wheel to zoom in/out<br>
                • Drag timeline to pan<br>
                • Double-click to reset zoom<br>
                • Keyboard: + to zoom in, - to zoom out, 0 to reset
            `;
            visualizationEl.appendChild(zoomTooltip);
            
            // Add event listeners for zoom buttons
            document.getElementById('zoom-in').addEventListener('click', () => {
                d3.select(svg).transition().call(zoom.scaleBy, 1.2);
            });
            
            document.getElementById('zoom-out').addEventListener('click', () => {
                d3.select(svg).transition().call(zoom.scaleBy, 0.8);
            });
            
            document.getElementById('zoom-reset').addEventListener('click', () => {
                d3.select(svg).transition().call(zoom.transform, d3.zoomIdentity);
            });
            
            // Add keyboard shortcuts for zooming
            document.addEventListener('keydown', (e) => {
                // Only process if we're not in an input field
                if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                    if (e.key === '+' || e.key === '=') {
                        d3.select(svg).transition().call(zoom.scaleBy, 1.2);
                        e.preventDefault();
                    } else if (e.key === '-' || e.key === '_') {
                        d3.select(svg).transition().call(zoom.scaleBy, 0.8);
                        e.preventDefault();
                    } else if (e.key === '0') {
                        d3.select(svg).transition().call(zoom.transform, d3.zoomIdentity);
                        e.preventDefault();
                    }
                }
            });
            
            // Add double-click to reset zoom
            svg.addEventListener('dblclick', () => {
                d3.select(svg).transition().call(zoom.transform, d3.zoomIdentity);
            });
            
            // Draw event data
            visibleEventTypes.forEach(type => {
                const typeEvents = filteredData.filter(event => event.type === type);
                
                typeEvents.forEach(event => {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', xScale(event.date));
                    // Store original date for zoom calculations
                    circle.setAttribute('data-x', event.date.getTime());
                    circle.setAttribute('cy', yScale(event.type) + config.barHeight / 2);
                    circle.setAttribute('r', 5);
                    circle.setAttribute('fill', colorScale(event.type));
                    
                    // Add interactivity
                    circle.addEventListener('mouseover', (e) => {
                        tooltipEl.style.opacity = 1;
                        tooltipEl.style.left = `${e.pageX + 10}px`;
                        tooltipEl.style.top = `${e.pageY + 10}px`;
                        
                        // Format tooltip content
                        let content = `<h3>${event.type}</h3>`;
                        content += `<p><strong>Datum:</strong> ${config.timeFormat(event.date)}</p>`;
                        content += `<p><strong>Status:</strong> ${event.status}</p>`;
                        
                        if (event.details) {
                            content += `<p><strong>Details:</strong> ${event.details}</p>`;
                        }
                        
                        tooltipEl.innerHTML = content;
                    });
                    
                    circle.addEventListener('mouseout', () => {
                        tooltipEl.style.opacity = 0;
                    });
                    
                    circlesGroup.appendChild(circle);
                    
                    // Connect points within the same event type with dotted lines
                    if (typeEvents.length > 1 && typeEvents.indexOf(event) < typeEvents.length - 1) {
                        const nextEvent = typeEvents[typeEvents.indexOf(event) + 1];
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', xScale(event.date));
                        line.setAttribute('x2', xScale(nextEvent.date));
                        // Store original dates for zoom calculations
                        line.setAttribute('data-x1', event.date.getTime());
                        line.setAttribute('data-x2', nextEvent.date.getTime());
                        line.setAttribute('y1', yScale(event.type) + config.barHeight / 2);
                        line.setAttribute('y2', yScale(event.type) + config.barHeight / 2);
                        line.setAttribute('stroke', colorScale(event.type));
                        line.setAttribute('stroke-width', 1);
                        line.setAttribute('stroke-dasharray', '3,3');
                        linesGroup.appendChild(line);
                    }
                });
            });
            
            // Add special marking for medication intake (Einnahme)
            const medicationEvents = filteredData.filter(event => event.type === 'Einnahme');
            medicationEvents.forEach(event => {
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                marker.setAttribute('x', xScale(event.date) - 2);
                // Store original date for zoom calculations
                marker.setAttribute('data-x', event.date.getTime());
                marker.setAttribute('y', 0);
                marker.setAttribute('width', 4);
                marker.setAttribute('height', (config.barHeight + config.barPadding) * visibleEventTypes.length);
                marker.setAttribute('fill', 'rgba(255, 0, 0, 0.1)');
                markersGroup.appendChild(marker);
            });
        }

        // Analyze patterns in the data
        function analyzeData() {
            const analysisDetailsEl = document.getElementById('analysis-details');
            if (!originalData || !originalData.events || originalData.events.length === 0) {
                analysisDetailsEl.innerHTML = '<p>Keine Daten für die Analyse verfügbar.</p>';
                return;
            }

            let analysisHTML = '';
            
            // 1. Count events by type
            const eventCounts = {};
            eventTypes.forEach(type => {
                eventCounts[type] = originalData.events.filter(e => e.type === type).length;
            });
            
            // Sort event types by count (descending)
            const sortedEventTypes = [...eventTypes].sort((a, b) => eventCounts[b] - eventCounts[a]);
            
            analysisHTML += '<h3>Ereignishäufigkeit</h3>';
            analysisHTML += '<ul>';
            sortedEventTypes.forEach(type => {
                analysisHTML += '<li><strong>' + type + ':</strong> ' + eventCounts[type] + ' Ereignisse</li>';
            });
            analysisHTML += '</ul>';
            
            // 2. Look at patterns between Einnahme and symptoms
            const medicationEvents = originalData.events.filter(e => e.type === 'Einnahme');
            
            if (medicationEvents.length > 0) {
                analysisHTML += '<h3>Muster nach Einnahme</h3>';
                
                // Check for symptom patterns after medication intake
                analysisHTML += '<p>Beobachtungen nach Mestinon-Einnahme:</p>';
                analysisHTML += '<ul>';
                
                // Track improvements and side effects
                const improvements = [];
                const sideEffects = [];
                
                // Analyze events after each medication intake
                medicationEvents.forEach(med => {
                    // Look at events within 4 hours after medication
                    const fourHoursLater = new Date(med.date.getTime() + 4 * 60 * 60 * 1000);
                    const eventsAfterMed = originalData.events.filter(e => 
                        e.date > med.date && e.date <= fourHoursLater && e.type !== 'Einnahme'
                    );
                    
                    eventsAfterMed.forEach(event => {
                        const timeDiff = (event.date - med.date) / (1000 * 60); // Time difference in minutes
                        
                        // Check if this is a positive effect
                        if (event.status.toLowerCase().includes('besser') || 
                            event.status.toLowerCase().includes('gut') || 
                            event.status.toLowerCase().includes('kein')) {
                            
                            if (!improvements.some(i => i.type === event.type)) {
                                improvements.push({
                                    type: event.type,
                                    timeRange: [timeDiff],
                                    status: [event.status]
                                });
                            } else {
                                const idx = improvements.findIndex(i => i.type === event.type);
                                improvements[idx].timeRange.push(timeDiff);
                                improvements[idx].status.push(event.status);
                            }
                        }
                        
                        // Check if this is a side effect
                        else if (event.type.toLowerCase().includes('durchfall') || 
                                event.type.toLowerCase().includes('übelkeit') || 
                                event.type.toLowerCase().includes('bauch') ||
                                event.status.toLowerCase().includes('schlecht')) {
                            
                            if (!sideEffects.some(i => i.type === event.type)) {
                                sideEffects.push({
                                    type: event.type,
                                    timeRange: [timeDiff],
                                    status: [event.status]
                                });
                            } else {
                                const idx = sideEffects.findIndex(i => i.type === event.type);
                                sideEffects[idx].timeRange.push(timeDiff);
                                sideEffects[idx].status.push(event.status);
                            }
                        }
                    });
                });
                
                // Calculate average times for improvements
                if (improvements.length > 0) {
                    analysisHTML += '<li><strong>Verbesserungen:</strong><ul>';
                    improvements.forEach(imp => {
                        const avgTime = imp.timeRange.reduce((a, b) => a + b, 0) / imp.timeRange.length;
                        analysisHTML += `<li>${imp.type}: Durchschnittlich ${Math.round(avgTime)} Minuten nach Einnahme</li>`;
                    });
                    analysisHTML += '</ul></li>';
                }
                
                // Calculate average times for side effects
                if (sideEffects.length > 0) {
                    analysisHTML += '<li><strong>Mögliche Nebenwirkungen:</strong><ul>';
                    sideEffects.forEach(side => {
                        const avgTime = side.timeRange.reduce((a, b) => a + b, 0) / side.timeRange.length;
                        analysisHTML += `<li>${side.type}: Durchschnittlich ${Math.round(avgTime)} Minuten nach Einnahme</li>`;
                    });
                    analysisHTML += '</ul></li>';
                }
                
                analysisHTML += '</ul>';
            }
            
            // Display the analysis results
            analysisDetailsEl.innerHTML = analysisHTML;
            
            // Estimate elimination half-life
            estimateHalfLife();
        }

        // Estimate elimination half-life
        function estimateHalfLife() {
            const halfLifeEstimationEl = document.getElementById('half-life-estimation');
            if (!originalData || !originalData.events || originalData.events.length === 0) {
                halfLifeEstimationEl.innerHTML = '<p>Keine Daten für die Schätzung verfügbar.</p>';
                return;
            }

            let halfLifeHTML = '';
            
            // Information from meta data
            halfLifeHTML += '<p><strong>Aus den Metadaten:</strong> Mittlere Halbwertszeit ca. 1.7 Stunden, bei Dialyse bis zu 2-3 fach verlängert.</p>';
            
            // Look for patterns of symptom recurrence
            const doppelsehenEvents = originalData.events.filter(e => e.type.includes('Doppelsehen'));
            const medicationEvents = originalData.events.filter(e => e.type === 'Einnahme');
            
            if (doppelsehenEvents.length > 0 && medicationEvents.length > 0) {
                // Find instances where symptoms return after medication
                const symptomsReturn = [];
                
                medicationEvents.forEach(med => {
                    // Find improvements after medication
                    const eventsAfterMed = doppelsehenEvents.filter(e => e.date > med.date);
                    
                    if (eventsAfterMed.length > 0) {
                        // First, look for improvement
                        const improvements = eventsAfterMed.filter(e => 
                            e.status.toLowerCase().includes('besser') || 
                            e.status.toLowerCase().includes('gut') || 
                            e.status.toLowerCase().includes('kein')
                        );
                        
                        if (improvements.length > 0) {
                            // Sort by time
                            improvements.sort((a, b) => a.date - b.date);
                            const firstImprovement = improvements[0];
                            
                            // Then look for deterioration after improvement
                            const deteriorations = eventsAfterMed.filter(e => 
                                e.date > firstImprovement.date &&
                                (e.status.toLowerCase().includes('schlecht') || 
                                e.status.toLowerCase().includes('stark') ||
                                e.status.toLowerCase().includes('vollständig'))
                            );
                            
                            if (deteriorations.length > 0) {
                                // Sort by time
                                deteriorations.sort((a, b) => a.date - b.date);
                                const firstDeterioration = deteriorations[0];
                                
                                // Calculate time from medication to deterioration
                                const timeToDeterioration = (firstDeterioration.date - med.date) / (1000 * 60 * 60); // hours
                                
                                symptomsReturn.push({
                                    medication: med,
                                    improvement: firstImprovement,
                                    deterioration: firstDeterioration,
                                    timeToDeterioration: timeToDeterioration
                                });
                            }
                        }
                    }
                });
                
                if (symptomsReturn.length > 0) {
                    // Calculate average time to symptom return
                    const avgTimeToDeterioration = symptomsReturn.reduce((sum, item) => sum + item.timeToDeterioration, 0) / symptomsReturn.length;
                    
                    // Estimate half-life based on symptom return
                    // Half-life is approximately time to deterioration divided by 5 (assuming 5 half-lives for significant deterioration)
                    const estimatedHalfLife = avgTimeToDeterioration / 5;
                    
                    halfLifeHTML += `<p><strong>Geschätzte Halbwertszeit basierend auf Symptomwiederkehr:</strong> Ungefähr ${estimatedHalfLife.toFixed(2)} Stunden</p>`;
                    
                    // Consider dialysis effect
                    const patientInfo = originalData.meta['medical-status'] || [];
                    const dialysisPatient = patientInfo.some(info => info.toLowerCase().includes('dialyse'));
                    
                    if (dialysisPatient) {
                        halfLifeHTML += '<p><strong>Mögliche Werte unter Berücksichtigung der Dialyse:</strong></p>';
                        halfLifeHTML += '<ul>';
                        halfLifeHTML += '<li>Minimum (ohne Dialyseeffekt): ' + (estimatedHalfLife / 3).toFixed(2) + ' Stunden</li>';
                        halfLifeHTML += '<li>Maximum (mit Dialyseeffekt): ' + estimatedHalfLife.toFixed(2) + ' Stunden</li>';
                        halfLifeHTML += '<li>Wahrscheinlichster Wert: ' + (estimatedHalfLife / 2).toFixed(2) + ' Stunden</li>';
                        halfLifeHTML += '</ul>';
                    }
                } else {
                    halfLifeHTML += '<p>Keine eindeutigen Muster für eine präzise Schätzung gefunden.</p>';
                    halfLifeHTML += '<p>Basierend auf der Literatur und den Patientendaten:</p>';
                    halfLifeHTML += '<ul>';
                    halfLifeHTML += '<li>Normale Halbwertszeit: 1.5-2 Stunden</li>';
                    halfLifeHTML += '<li>Bei Niereninsuffizienz/Dialyse: 3-6 Stunden (verlängert)</li>';
                    halfLifeHTML += '</ul>';
                }
            } else {
                halfLifeHTML += '<p>Nicht genügend Daten für eine Schätzung verfügbar.</p>';
            }
            
            // Display the half-life estimation
            halfLifeEstimationEl.innerHTML = halfLifeHTML;
        }

        // Update the visualization
        function updateVisualization() {
            createVisualization();
        }

        // Initialize the dashboard
        async function initDashboard() {
            // Load and process data
            const rawData = await loadData();
            if (!rawData) return;
            
            originalData = processData(rawData);
            filteredData = originalData.events;
            
            // Create filters and legend
            createFilters();
            createLegend();
            
            // Create initial visualization
            createVisualization();
            
            // Analyze data and display results
            analyzeData();
            
            // Handle window resize
            window.addEventListener('resize', debounce(updateVisualization, 250));
        }

        // Helper function to debounce resize events
        function debounce(func, wait) {
            let timeout;
            return function() {
                const context = this, args = arguments;
                const later = function() {
                    timeout = null;
                    func.apply(context, args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Initialize when the page is loaded
        document.addEventListener('DOMContentLoaded', initDashboard);
        
        // Function to check for updates to the protocol file
        async function checkForUpdates() {
            try {
                const response = await fetch('data/mestinon-intake-protocol.json', { 
                    cache: 'no-store' 
                });
                const newData = await response.json();
                
                // Simple check if data has changed (comparing lengths)
                if (originalData && originalData.events.length !== newData.events.length) {
                    console.log('Data has changed, reloading...');
                    originalData = processData(newData);
                    filteredData = originalData.events;
                    createFilters();
                    createLegend();
                    updateVisualization();
                }
            } catch (error) {
                console.error('Error checking for updates:', error);
            }
        }
        
        // Check for updates periodically (every 5 minutes)
        setInterval(checkForUpdates, 5 * 60 * 1000);
    </script>
</body>
</html>